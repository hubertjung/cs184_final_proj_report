<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184 Final Project Proposal</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
//   MathJax.Hub.Config({
//     jax: ["input/TeX","output/HTML-CSS"],
//     displayAlign: "left"
// });
</script>
</head>

<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2017</h1>
<h1 align="middle">Fluid Simulation Project Report</h1>
<h2 align="middle">Team Members: Hubert Jung, Akshay Madhani</h2>
<br>

<div>

<h2 align="left">Abstract</h2>
<p>
In our project we implement fluid simulation by modeling fluids as particles as described in <a href="http://mmacklin.com/pbf_sig_preprint.pdf">Position Based Fluids</a> (Macklin and Müller). This simulation method uses Position Based Dynamics and is based on Smoothed Particle Hydrodynamics (SPH). The big improvement that this method makes over traditional SPH is the ability to efficiently enforce incompressiblity, or constant fluid density. It adds an artificial pressure term to deal with negative pressures and create a surface tension effect. It also includes vorticity confinement to counteract damping, and XSPH viscosity for more coherent motion. The density calculations as well as particle collisions require us to find neighbors of particles, which we are able to compute efficiently using a grid structure.
</p>

<h2 align="left">Overall Loop</h2>
<p>
Our overall simulation loop follows the structure given in Macklin and Müller. This loop can be roughly divided into the following steps: 
  <ol>
    <li> Apply forces and predict new particle positions </li>
    <li> Form the particle grid and find neighbors </li>
    <li> Repeat for <i>n</i> iterations:
      <ul>
        <li> Apply incompressiblity constraints and artificial pressure </li>
        <li> Calculate particle collisions and environment collisions </li>
      </ul>
    </li>
    <li> Update velocity and position and apply vorticity confinement and viscosity </li>
  </ol> 
</p>

<h2 align="left">Applying forces</h2>
<p>
For each particle, we calculate the change in velocity due to forces, and predict the change in position due to velocity. We use two simple physics equations: 
$$ v_t = v_{t-1} + a{\Delta}t$$
$$ x_t = x_{t-1} + v{\Delta}t$$
</p>

<h2 align="left">Finding neighbors</h2>
<p>
We use a grid-based method to find neighbors. The simulation space is divided into boxes of width <i>w</i> equal to the diameter of a particle. The box a particle is located in is given by the equation:
$$ p_{box} = floor(\frac{p_{particle}}{w}) $$ 
We form a unique hash from the coordinates of the box and store the particle in a map keyed at that hash. 
</p>
<div align="middle">
<img src="images/grid.png" width="600px"/>
<figcaption>Illustration of particles in a grid. Image from <i>Particle Simulation using CUDA</i> (Simon Green)</figcaption>
</div>
<p>
This grid structure greatly reduces the number of particles we need to consider when forming the set of neighbors. For example, for particle collisions we only need to consider the particles located up to one box away. Thus, we would need to iterate over 27 boxes ([-1, 1] in each dimension).
</p> 

<h2 align="left">Collisions</h2>
<p>
For each particle, we test for collisions with its neighboring particles and with the environment. If a particle's predicted location is within \(2*radius\) of a neighbor, we simply move it along the vector connecting the two particles so that it is no longer overlapping with the neighbor. We also check to see if the predicted position is on the opposite side of wall from its initial position. If so, we shorten the distance that the particle travels so that it no longer crosses the wall.
<br> <br>
Note: while we implemented collisions first, they are calculated after all other changes to particle positions.
</p>
<table style="width:100%">
  <tr>
    <td>
      <img src="gifs/basic.gif" width="480px"/>
      <figcaption align="middle">Particles falling and colliding</figcaption>
    </td>
    <td>
      <img src="gifs/basic_random.gif" width="480px"/>
      <figcaption align="middle">With randomized starting positions</figcaption>
    </td>
  </tr>
</table>


<h2 align="left">Incompressibility</h2>
<p>
In order to maximize realism, we want to enforce incompressibility. Another way of saying this is that we want the density \(\rho_i\) at each point in the fluid to be equal to a constant rest density \(\rho_o\). This is captured mathematically with the constraint

$$ C_i(\pmb{\textrm{p}}_1,...,\pmb{\textrm{p}}_n) = \frac{\rho_i}{\rho_0} - 1$$

where \(\pmb{\textrm{p}}_1,...,\pmb{\textrm{p}}_n\) represents the set of the particle and its neighbors. We can calculate \(\rho_i\) with the standard SPH density estimator

$$ \rho_i = \sum_j m_jW(\pmb{\textrm{p}}_i - \pmb{\textrm{p}}_j, h)$$

W(<b>r</b>, h) is a smoothing kernel that is only non-zero when \(0 \leq \lvert{\pmb{r}}\rvert \leq h\). Following <a href="http://matthias-mueller-fischer.ch/publications/sca03.pdf"> this paper</a> (Müller et al.), we use the Poly6 kernel for density and the Spiky kernel for the gradient.

$$ W_{poly6}(\pmb{\textrm{r}}, h) = \frac{315}{64\pi h^9}(h^2-{\lvert \pmb{\textrm{r}} \rvert}^2)^3 \quad 0 \leq {\lvert \pmb{\textrm{r}} \rvert} \leq h$$

<figure align="middle">
  <img src="images/poly.png" width="200px"/>
  <figcaption>Poly6 kernel and its gradient shown by the thick and thin lines, respectively. Image from Müller et al.</figcaption>
</figure>

Our goal in this step is to find a correction vector \(\Delta \pmb{\textrm{p}}\) that can be applied to the position to satisfy the constraint.

$$ C(\pmb{\textrm{p}} + \Delta \pmb{\textrm{p}}) = 0$$

We use Newton's method, stepping along the gradient of the constraint.

$$ \Delta \pmb{\textrm{p}} \approx \nabla C(\pmb{\textrm{p}}) \lambda $$
$$ C(\pmb{\textrm{p}} + \Delta \pmb{\textrm{p}}) \approx C(\pmb{\textrm{p}}) + \nabla C^T \Delta \pmb{\textrm{p}} = 0 $$

Plugging the first equation into the second and solving for lambda yields:

$$ \lambda_i = -\frac{C_i(\pmb{\textrm{p}}_1,...,\pmb{\textrm{p}}_n)}{\sum_k \lvert \nabla_{p_k} C_i \rvert^2 + \varepsilon}$$

where \(\varepsilon\) is an adjustable regularization paramater. The gradient of the constraint is given by
$$\nabla_{p_k} C_i = \frac{1}{\rho_o} \sum_j \nabla_{p_k} W(\pmb{\textrm{p}}_i - \pmb{\textrm{p}}_j, h) $$

You can see from the figure above that the gradient of the Poly6 kernel approaches 0 as r becomes smaller. This would lead to clumping as particles close together would have a very small gradient value. Thus, we instead use the gradient of the Spiky kernel:

$$ W_{spiky}(\pmb{\textrm{r}}, h) = \frac{15}{\pi h^6}(h-{\lvert \pmb{\textrm{r}} \rvert})^3 \quad 0 \leq {\lvert \pmb{\textrm{r}} \rvert} \leq h$$
$$ \nabla W_{spiky}(\pmb{\textrm{r}}, h) = -\frac{45}{\pi h^6}(h-{\lvert \pmb{\textrm{r}} \rvert})^2\frac{\pmb{\textrm{r}}}{{\lvert \pmb{\textrm{r}} \rvert}} \quad 0 < {\lvert \pmb{\textrm{r}} \rvert} \leq h$$

<figure align="middle">
  <img src="images/spiky.png" width="200px"/>
  <figcaption>Spiky kernel and its gradient shown by the thick and thin lines, respectively. Image from Müller et al.</figcaption>
</figure>

Our final equation for the correction vector \(\Delta \pmb{\textrm{p}}\) is
$$ \Delta \pmb{\textrm{p}}_i = \frac{1}{\rho_0} \sum_j(\lambda_i + \lambda_j) \nabla W(\pmb{\textrm{p}}_i - \pmb{\textrm{p}}_j, h). $$

</p>

<h2 align="left">Video</h2>
<div align="middle">
<iframe width="640" height="360" src="https://www.youtube.com/embed/tLOKEaRWL-o" frameborder="0" allowfullscreen></iframe>
</div>

</div>
</body>
</html>
